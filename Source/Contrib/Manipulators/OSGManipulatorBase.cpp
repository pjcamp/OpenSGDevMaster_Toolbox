/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Manipulator!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include "OSGConfig.h"



#include "OSGNode.h"                    // Target Class
#include "OSGViewport.h"                // Viewport Class
#include "OSGGeometry.h"                // XGeometries Class
#include "OSGMaterial.h"                // MaterialX Class

#include "OSGManipulatorBase.h"
#include "OSGManipulator.h"

#include <boost/bind.hpp>

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Manipulator
    Baseclass for all Manipulators
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var Node *          ManipulatorBase::_sfTarget
    
*/

/*! \var UInt16          ManipulatorBase::_sfActiveHandle
    the active sub handle
*/

/*! \var UInt16          ManipulatorBase::_sfRolloverHandle
    the active sub handle
*/

/*! \var Pnt2f           ManipulatorBase::_sfStartMousePos
    Last mouse position (in pixel, although 2f is used!)
*/

/*! \var Viewport *      ManipulatorBase::_sfViewport
    
*/

/*! \var bool            ManipulatorBase::_sfMaintainScreenSize
    If MaintainScreenSize is true then the manipulator will be drawn the same size on the screen regardless of the distance of the manipulor target from the camera.
*/

/*! \var Real32          ManipulatorBase::_sfManipulatorScreenDepth
    The distance from the screen that the manipulator is drawn.
*/

/*! \var Vec3f           ManipulatorBase::_sfLength
    The length of the three axes in one vector
*/

/*! \var Vec3f           ManipulatorBase::_sfWidth
    The width of the three axes in one vector
*/

/*! \var Geometry *      ManipulatorBase::_mfXGeometries
    The node for the x-handle geometry
*/

/*! \var Geometry *      ManipulatorBase::_mfYGeometries
    The node for the y-handle geometry
*/

/*! \var Geometry *      ManipulatorBase::_mfZGeometries
    The node for the z-handle geometry
*/

/*! \var Material *      ManipulatorBase::_sfMaterialX
    material for the x-axis geometry
*/

/*! \var Material *      ManipulatorBase::_sfMaterialY
    material for the y-axis geometry
*/

/*! \var Material *      ManipulatorBase::_sfMaterialZ
    material for the z-axis geometry
*/

/*! \var Material *      ManipulatorBase::_sfMaterialSelected
    material for the axis geometry while selected
*/

/*! \var Material *      ManipulatorBase::_sfMaterialRollover
    material for the axis geometry while rolled over
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<Manipulator *>::_type("ManipulatorPtr", "TransformPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(Manipulator *)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           Manipulator *,
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           Manipulator *,
                           0);

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void ManipulatorBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUnrecNodePtr::Description(
        SFUnrecNodePtr::getClassType(),
        "target",
        "",
        TargetFieldId, TargetFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleTarget),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleTarget));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt16::Description(
        SFUInt16::getClassType(),
        "activeHandle",
        "the active sub handle\n",
        ActiveHandleFieldId, ActiveHandleFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleActiveHandle),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleActiveHandle));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt16::Description(
        SFUInt16::getClassType(),
        "rolloverHandle",
        "the active sub handle\n",
        RolloverHandleFieldId, RolloverHandleFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleRolloverHandle),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleRolloverHandle));

    oType.addInitialDesc(pDesc);

    pDesc = new SFPnt2f::Description(
        SFPnt2f::getClassType(),
        "startMousePos",
        "Last mouse position (in pixel, although 2f is used!)\n",
        StartMousePosFieldId, StartMousePosFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleStartMousePos),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleStartMousePos));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecViewportPtr::Description(
        SFUnrecViewportPtr::getClassType(),
        "viewport",
        "",
        ViewportFieldId, ViewportFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleViewport),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleViewport));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "maintainScreenSize",
        "If MaintainScreenSize is true then the manipulator will be drawn the same size on the screen regardless of the distance of the manipulor target from the camera.\n",
        MaintainScreenSizeFieldId, MaintainScreenSizeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleMaintainScreenSize),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleMaintainScreenSize));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "manipulatorScreenDepth",
        "The distance from the screen that the manipulator is drawn.\n",
        ManipulatorScreenDepthFieldId, ManipulatorScreenDepthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleManipulatorScreenDepth),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleManipulatorScreenDepth));

    oType.addInitialDesc(pDesc);

    pDesc = new SFVec3f::Description(
        SFVec3f::getClassType(),
        "length",
        "The length of the three axes in one vector\n",
        LengthFieldId, LengthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleLength),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleLength));

    oType.addInitialDesc(pDesc);

    pDesc = new SFVec3f::Description(
        SFVec3f::getClassType(),
        "width",
        "The width of the three axes in one vector\n",
        WidthFieldId, WidthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleWidth),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleWidth));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecGeometryPtr::Description(
        MFUnrecGeometryPtr::getClassType(),
        "XGeometries",
        "The node for the x-handle geometry\n",
        XGeometriesFieldId, XGeometriesFieldMask,
        true,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleXGeometries),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleXGeometries));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecGeometryPtr::Description(
        MFUnrecGeometryPtr::getClassType(),
        "YGeometries",
        "The node for the y-handle geometry\n",
        YGeometriesFieldId, YGeometriesFieldMask,
        true,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleYGeometries),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleYGeometries));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecGeometryPtr::Description(
        MFUnrecGeometryPtr::getClassType(),
        "ZGeometries",
        "The node for the z-handle geometry\n",
        ZGeometriesFieldId, ZGeometriesFieldMask,
        true,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleZGeometries),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleZGeometries));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecMaterialPtr::Description(
        SFUnrecMaterialPtr::getClassType(),
        "materialX",
        "material for the x-axis geometry\n",
        MaterialXFieldId, MaterialXFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleMaterialX),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleMaterialX));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecMaterialPtr::Description(
        SFUnrecMaterialPtr::getClassType(),
        "materialY",
        "material for the y-axis geometry\n",
        MaterialYFieldId, MaterialYFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleMaterialY),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleMaterialY));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecMaterialPtr::Description(
        SFUnrecMaterialPtr::getClassType(),
        "materialZ",
        "material for the z-axis geometry\n",
        MaterialZFieldId, MaterialZFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleMaterialZ),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleMaterialZ));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecMaterialPtr::Description(
        SFUnrecMaterialPtr::getClassType(),
        "materialSelected",
        "material for the axis geometry while selected\n",
        MaterialSelectedFieldId, MaterialSelectedFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleMaterialSelected),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleMaterialSelected));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecMaterialPtr::Description(
        SFUnrecMaterialPtr::getClassType(),
        "materialRollover",
        "material for the axis geometry while rolled over\n",
        MaterialRolloverFieldId, MaterialRolloverFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Manipulator::editHandleMaterialRollover),
        static_cast<FieldGetMethodSig >(&Manipulator::getHandleMaterialRollover));

    oType.addInitialDesc(pDesc);
}


ManipulatorBase::TypeObject ManipulatorBase::_type(
    ManipulatorBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    NULL,
    Manipulator::initMethod,
    Manipulator::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&Manipulator::classDescInserter),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"Manipulator\"\n"
    "\tparent=\"Transform\"\n"
    "\tlibrary=\"ContribGUI\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"abstract\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "\tdecoratable=\"false\"\n"
    "\tuseLocalIncludes=\"false\"\n"
    ">\n"
    "Baseclass for all Manipulators\n"
    "\t<Field\n"
    "\t\tname=\"target\"\n"
    "\t\ttype=\"Node\"\n"
    "\t\tcategory=\"pointer\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"activeHandle\"\n"
    "\t\ttype=\"UInt16\"\n"
    "\t\tcategory=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"Manipulator::NO_AXES_HANDLE\"\n"
    "\t>\n"
    "\tthe active sub handle\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"rolloverHandle\"\n"
    "\t\ttype=\"UInt16\"\n"
    "\t\tcategory=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"Manipulator::NO_AXES_HANDLE\"\n"
    "\t>\n"
    "\tthe active sub handle\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"startMousePos\"\n"
    "\t\ttype=\"Pnt2f\"\n"
    "\t\tcategory=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"protected\"\n"
    "\t>\n"
    "\tLast mouse position (in pixel, although 2f is used!)\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"viewport\"\n"
    "\t\ttype=\"Viewport\"\n"
    "\t\tcategory=\"pointer\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\tdefaultValue=\"NULL\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"maintainScreenSize\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcategory=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"true\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tIf MaintainScreenSize is true then the manipulator will be drawn the same size on the screen regardless of the distance of the manipulor target from the camera.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"manipulatorScreenDepth\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcategory=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"10.0f\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe distance from the screen that the manipulator is drawn.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"length\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcategory=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1.0f,1.0f,1.0f\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe length of the three axes in one vector\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"width\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcategory=\"data\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0.025f,0.025f,0.025f\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe width of the three axes in one vector\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"XGeometries\"\n"
    "\t\ttype=\"Geometry\"\n"
    "\t\tcategory=\"pointer\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\taccess=\"protected\"\n"
    "\t>\n"
    "\tThe node for the x-handle geometry\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"YGeometries\"\n"
    "\t\ttype=\"Geometry\"\n"
    "\t\tcategory=\"pointer\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\taccess=\"protected\"\n"
    "\t>\n"
    "\tThe node for the y-handle geometry\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"ZGeometries\"\n"
    "\t\ttype=\"Geometry\"\n"
    "\t\tcategory=\"pointer\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\taccess=\"protected\"\n"
    "\t>\n"
    "\tThe node for the z-handle geometry\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"materialX\"\n"
    "\t\ttype=\"Material\"\n"
    "\t\tcategory=\"pointer\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tmaterial for the x-axis geometry\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"materialY\"\n"
    "\t\ttype=\"Material\"\n"
    "\t\tcategory=\"pointer\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tmaterial for the y-axis geometry\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"materialZ\"\n"
    "\t\ttype=\"Material\"\n"
    "\t\tcategory=\"pointer\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tmaterial for the z-axis geometry\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"materialSelected\"\n"
    "\t\ttype=\"Material\"\n"
    "\t\tcategory=\"pointer\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tmaterial for the axis geometry while selected\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"materialRollover\"\n"
    "\t\ttype=\"Material\"\n"
    "\t\tcategory=\"pointer\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tmaterial for the axis geometry while rolled over\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    "Baseclass for all Manipulators\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &ManipulatorBase::getType(void)
{
    return _type;
}

const FieldContainerType &ManipulatorBase::getType(void) const
{
    return _type;
}

UInt32 ManipulatorBase::getContainerSize(void) const
{
    return sizeof(Manipulator);
}

/*------------------------- decorator get ------------------------------*/


//! Get the Manipulator::_sfTarget field.
const SFUnrecNodePtr *ManipulatorBase::getSFTarget(void) const
{
    return &_sfTarget;
}

SFUnrecNodePtr      *ManipulatorBase::editSFTarget         (void)
{
    editSField(TargetFieldMask);

    return &_sfTarget;
}

SFUInt16 *ManipulatorBase::editSFActiveHandle(void)
{
    editSField(ActiveHandleFieldMask);

    return &_sfActiveHandle;
}

const SFUInt16 *ManipulatorBase::getSFActiveHandle(void) const
{
    return &_sfActiveHandle;
}


SFUInt16 *ManipulatorBase::editSFRolloverHandle(void)
{
    editSField(RolloverHandleFieldMask);

    return &_sfRolloverHandle;
}

const SFUInt16 *ManipulatorBase::getSFRolloverHandle(void) const
{
    return &_sfRolloverHandle;
}


SFPnt2f *ManipulatorBase::editSFStartMousePos(void)
{
    editSField(StartMousePosFieldMask);

    return &_sfStartMousePos;
}

const SFPnt2f *ManipulatorBase::getSFStartMousePos(void) const
{
    return &_sfStartMousePos;
}


//! Get the Manipulator::_sfViewport field.
const SFUnrecViewportPtr *ManipulatorBase::getSFViewport(void) const
{
    return &_sfViewport;
}

SFUnrecViewportPtr  *ManipulatorBase::editSFViewport       (void)
{
    editSField(ViewportFieldMask);

    return &_sfViewport;
}

SFBool *ManipulatorBase::editSFMaintainScreenSize(void)
{
    editSField(MaintainScreenSizeFieldMask);

    return &_sfMaintainScreenSize;
}

const SFBool *ManipulatorBase::getSFMaintainScreenSize(void) const
{
    return &_sfMaintainScreenSize;
}


SFReal32 *ManipulatorBase::editSFManipulatorScreenDepth(void)
{
    editSField(ManipulatorScreenDepthFieldMask);

    return &_sfManipulatorScreenDepth;
}

const SFReal32 *ManipulatorBase::getSFManipulatorScreenDepth(void) const
{
    return &_sfManipulatorScreenDepth;
}


SFVec3f *ManipulatorBase::editSFLength(void)
{
    editSField(LengthFieldMask);

    return &_sfLength;
}

const SFVec3f *ManipulatorBase::getSFLength(void) const
{
    return &_sfLength;
}


SFVec3f *ManipulatorBase::editSFWidth(void)
{
    editSField(WidthFieldMask);

    return &_sfWidth;
}

const SFVec3f *ManipulatorBase::getSFWidth(void) const
{
    return &_sfWidth;
}


//! Get the Manipulator::_mfXGeometries field.
const MFUnrecGeometryPtr *ManipulatorBase::getMFXGeometries(void) const
{
    return &_mfXGeometries;
}

MFUnrecGeometryPtr  *ManipulatorBase::editMFXGeometries    (void)
{
    editMField(XGeometriesFieldMask, _mfXGeometries);

    return &_mfXGeometries;
}

//! Get the Manipulator::_mfYGeometries field.
const MFUnrecGeometryPtr *ManipulatorBase::getMFYGeometries(void) const
{
    return &_mfYGeometries;
}

MFUnrecGeometryPtr  *ManipulatorBase::editMFYGeometries    (void)
{
    editMField(YGeometriesFieldMask, _mfYGeometries);

    return &_mfYGeometries;
}

//! Get the Manipulator::_mfZGeometries field.
const MFUnrecGeometryPtr *ManipulatorBase::getMFZGeometries(void) const
{
    return &_mfZGeometries;
}

MFUnrecGeometryPtr  *ManipulatorBase::editMFZGeometries    (void)
{
    editMField(ZGeometriesFieldMask, _mfZGeometries);

    return &_mfZGeometries;
}

//! Get the Manipulator::_sfMaterialX field.
const SFUnrecMaterialPtr *ManipulatorBase::getSFMaterialX(void) const
{
    return &_sfMaterialX;
}

SFUnrecMaterialPtr  *ManipulatorBase::editSFMaterialX      (void)
{
    editSField(MaterialXFieldMask);

    return &_sfMaterialX;
}

//! Get the Manipulator::_sfMaterialY field.
const SFUnrecMaterialPtr *ManipulatorBase::getSFMaterialY(void) const
{
    return &_sfMaterialY;
}

SFUnrecMaterialPtr  *ManipulatorBase::editSFMaterialY      (void)
{
    editSField(MaterialYFieldMask);

    return &_sfMaterialY;
}

//! Get the Manipulator::_sfMaterialZ field.
const SFUnrecMaterialPtr *ManipulatorBase::getSFMaterialZ(void) const
{
    return &_sfMaterialZ;
}

SFUnrecMaterialPtr  *ManipulatorBase::editSFMaterialZ      (void)
{
    editSField(MaterialZFieldMask);

    return &_sfMaterialZ;
}

//! Get the Manipulator::_sfMaterialSelected field.
const SFUnrecMaterialPtr *ManipulatorBase::getSFMaterialSelected(void) const
{
    return &_sfMaterialSelected;
}

SFUnrecMaterialPtr  *ManipulatorBase::editSFMaterialSelected(void)
{
    editSField(MaterialSelectedFieldMask);

    return &_sfMaterialSelected;
}

//! Get the Manipulator::_sfMaterialRollover field.
const SFUnrecMaterialPtr *ManipulatorBase::getSFMaterialRollover(void) const
{
    return &_sfMaterialRollover;
}

SFUnrecMaterialPtr  *ManipulatorBase::editSFMaterialRollover(void)
{
    editSField(MaterialRolloverFieldMask);

    return &_sfMaterialRollover;
}



void ManipulatorBase::pushToXGeometries(Geometry * const value)
{
    editMField(XGeometriesFieldMask, _mfXGeometries);

    _mfXGeometries.push_back(value);
}

void ManipulatorBase::assignXGeometries(const MFUnrecGeometryPtr &value)
{
    MFUnrecGeometryPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecGeometryPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<Manipulator *>(this)->clearXGeometries();

    while(elemIt != elemEnd)
    {
        this->pushToXGeometries(*elemIt);

        ++elemIt;
    }
}

void ManipulatorBase::removeFromXGeometries(UInt32 uiIndex)
{
    if(uiIndex < _mfXGeometries.size())
    {
        editMField(XGeometriesFieldMask, _mfXGeometries);

        _mfXGeometries.erase(uiIndex);
    }
}

void ManipulatorBase::removeObjFromXGeometries(Geometry * const value)
{
    Int32 iElemIdx = _mfXGeometries.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(XGeometriesFieldMask, _mfXGeometries);

        _mfXGeometries.erase(iElemIdx);
    }
}
void ManipulatorBase::clearXGeometries(void)
{
    editMField(XGeometriesFieldMask, _mfXGeometries);


    _mfXGeometries.clear();
}

void ManipulatorBase::pushToYGeometries(Geometry * const value)
{
    editMField(YGeometriesFieldMask, _mfYGeometries);

    _mfYGeometries.push_back(value);
}

void ManipulatorBase::assignYGeometries(const MFUnrecGeometryPtr &value)
{
    MFUnrecGeometryPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecGeometryPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<Manipulator *>(this)->clearYGeometries();

    while(elemIt != elemEnd)
    {
        this->pushToYGeometries(*elemIt);

        ++elemIt;
    }
}

void ManipulatorBase::removeFromYGeometries(UInt32 uiIndex)
{
    if(uiIndex < _mfYGeometries.size())
    {
        editMField(YGeometriesFieldMask, _mfYGeometries);

        _mfYGeometries.erase(uiIndex);
    }
}

void ManipulatorBase::removeObjFromYGeometries(Geometry * const value)
{
    Int32 iElemIdx = _mfYGeometries.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(YGeometriesFieldMask, _mfYGeometries);

        _mfYGeometries.erase(iElemIdx);
    }
}
void ManipulatorBase::clearYGeometries(void)
{
    editMField(YGeometriesFieldMask, _mfYGeometries);


    _mfYGeometries.clear();
}

void ManipulatorBase::pushToZGeometries(Geometry * const value)
{
    editMField(ZGeometriesFieldMask, _mfZGeometries);

    _mfZGeometries.push_back(value);
}

void ManipulatorBase::assignZGeometries(const MFUnrecGeometryPtr &value)
{
    MFUnrecGeometryPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecGeometryPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<Manipulator *>(this)->clearZGeometries();

    while(elemIt != elemEnd)
    {
        this->pushToZGeometries(*elemIt);

        ++elemIt;
    }
}

void ManipulatorBase::removeFromZGeometries(UInt32 uiIndex)
{
    if(uiIndex < _mfZGeometries.size())
    {
        editMField(ZGeometriesFieldMask, _mfZGeometries);

        _mfZGeometries.erase(uiIndex);
    }
}

void ManipulatorBase::removeObjFromZGeometries(Geometry * const value)
{
    Int32 iElemIdx = _mfZGeometries.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(ZGeometriesFieldMask, _mfZGeometries);

        _mfZGeometries.erase(iElemIdx);
    }
}
void ManipulatorBase::clearZGeometries(void)
{
    editMField(ZGeometriesFieldMask, _mfZGeometries);


    _mfZGeometries.clear();
}



/*------------------------------ access -----------------------------------*/

UInt32 ManipulatorBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        returnValue += _sfTarget.getBinSize();
    }
    if(FieldBits::NoField != (ActiveHandleFieldMask & whichField))
    {
        returnValue += _sfActiveHandle.getBinSize();
    }
    if(FieldBits::NoField != (RolloverHandleFieldMask & whichField))
    {
        returnValue += _sfRolloverHandle.getBinSize();
    }
    if(FieldBits::NoField != (StartMousePosFieldMask & whichField))
    {
        returnValue += _sfStartMousePos.getBinSize();
    }
    if(FieldBits::NoField != (ViewportFieldMask & whichField))
    {
        returnValue += _sfViewport.getBinSize();
    }
    if(FieldBits::NoField != (MaintainScreenSizeFieldMask & whichField))
    {
        returnValue += _sfMaintainScreenSize.getBinSize();
    }
    if(FieldBits::NoField != (ManipulatorScreenDepthFieldMask & whichField))
    {
        returnValue += _sfManipulatorScreenDepth.getBinSize();
    }
    if(FieldBits::NoField != (LengthFieldMask & whichField))
    {
        returnValue += _sfLength.getBinSize();
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        returnValue += _sfWidth.getBinSize();
    }
    if(FieldBits::NoField != (XGeometriesFieldMask & whichField))
    {
        returnValue += _mfXGeometries.getBinSize();
    }
    if(FieldBits::NoField != (YGeometriesFieldMask & whichField))
    {
        returnValue += _mfYGeometries.getBinSize();
    }
    if(FieldBits::NoField != (ZGeometriesFieldMask & whichField))
    {
        returnValue += _mfZGeometries.getBinSize();
    }
    if(FieldBits::NoField != (MaterialXFieldMask & whichField))
    {
        returnValue += _sfMaterialX.getBinSize();
    }
    if(FieldBits::NoField != (MaterialYFieldMask & whichField))
    {
        returnValue += _sfMaterialY.getBinSize();
    }
    if(FieldBits::NoField != (MaterialZFieldMask & whichField))
    {
        returnValue += _sfMaterialZ.getBinSize();
    }
    if(FieldBits::NoField != (MaterialSelectedFieldMask & whichField))
    {
        returnValue += _sfMaterialSelected.getBinSize();
    }
    if(FieldBits::NoField != (MaterialRolloverFieldMask & whichField))
    {
        returnValue += _sfMaterialRollover.getBinSize();
    }

    return returnValue;
}

void ManipulatorBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        _sfTarget.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ActiveHandleFieldMask & whichField))
    {
        _sfActiveHandle.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RolloverHandleFieldMask & whichField))
    {
        _sfRolloverHandle.copyToBin(pMem);
    }
    if(FieldBits::NoField != (StartMousePosFieldMask & whichField))
    {
        _sfStartMousePos.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ViewportFieldMask & whichField))
    {
        _sfViewport.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MaintainScreenSizeFieldMask & whichField))
    {
        _sfMaintainScreenSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ManipulatorScreenDepthFieldMask & whichField))
    {
        _sfManipulatorScreenDepth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LengthFieldMask & whichField))
    {
        _sfLength.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        _sfWidth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (XGeometriesFieldMask & whichField))
    {
        _mfXGeometries.copyToBin(pMem);
    }
    if(FieldBits::NoField != (YGeometriesFieldMask & whichField))
    {
        _mfYGeometries.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ZGeometriesFieldMask & whichField))
    {
        _mfZGeometries.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MaterialXFieldMask & whichField))
    {
        _sfMaterialX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MaterialYFieldMask & whichField))
    {
        _sfMaterialY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MaterialZFieldMask & whichField))
    {
        _sfMaterialZ.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MaterialSelectedFieldMask & whichField))
    {
        _sfMaterialSelected.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MaterialRolloverFieldMask & whichField))
    {
        _sfMaterialRollover.copyToBin(pMem);
    }
}

void ManipulatorBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        editSField(TargetFieldMask);
        _sfTarget.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ActiveHandleFieldMask & whichField))
    {
        editSField(ActiveHandleFieldMask);
        _sfActiveHandle.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RolloverHandleFieldMask & whichField))
    {
        editSField(RolloverHandleFieldMask);
        _sfRolloverHandle.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (StartMousePosFieldMask & whichField))
    {
        editSField(StartMousePosFieldMask);
        _sfStartMousePos.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ViewportFieldMask & whichField))
    {
        editSField(ViewportFieldMask);
        _sfViewport.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MaintainScreenSizeFieldMask & whichField))
    {
        editSField(MaintainScreenSizeFieldMask);
        _sfMaintainScreenSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ManipulatorScreenDepthFieldMask & whichField))
    {
        editSField(ManipulatorScreenDepthFieldMask);
        _sfManipulatorScreenDepth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LengthFieldMask & whichField))
    {
        editSField(LengthFieldMask);
        _sfLength.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        editSField(WidthFieldMask);
        _sfWidth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (XGeometriesFieldMask & whichField))
    {
        editMField(XGeometriesFieldMask, _mfXGeometries);
        _mfXGeometries.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (YGeometriesFieldMask & whichField))
    {
        editMField(YGeometriesFieldMask, _mfYGeometries);
        _mfYGeometries.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ZGeometriesFieldMask & whichField))
    {
        editMField(ZGeometriesFieldMask, _mfZGeometries);
        _mfZGeometries.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MaterialXFieldMask & whichField))
    {
        editSField(MaterialXFieldMask);
        _sfMaterialX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MaterialYFieldMask & whichField))
    {
        editSField(MaterialYFieldMask);
        _sfMaterialY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MaterialZFieldMask & whichField))
    {
        editSField(MaterialZFieldMask);
        _sfMaterialZ.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MaterialSelectedFieldMask & whichField))
    {
        editSField(MaterialSelectedFieldMask);
        _sfMaterialSelected.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MaterialRolloverFieldMask & whichField))
    {
        editSField(MaterialRolloverFieldMask);
        _sfMaterialRollover.copyFromBin(pMem);
    }
}



/*------------------------- constructors ----------------------------------*/

ManipulatorBase::ManipulatorBase(void) :
    Inherited(),
    _sfTarget                 (NULL),
    _sfActiveHandle           (UInt16(Manipulator::NO_AXES_HANDLE)),
    _sfRolloverHandle         (UInt16(Manipulator::NO_AXES_HANDLE)),
    _sfStartMousePos          (),
    _sfViewport               (NULL),
    _sfMaintainScreenSize     (bool(true)),
    _sfManipulatorScreenDepth (Real32(10.0f)),
    _sfLength                 (Vec3f(1.0f,1.0f,1.0f)),
    _sfWidth                  (Vec3f(0.025f,0.025f,0.025f)),
    _mfXGeometries            (),
    _mfYGeometries            (),
    _mfZGeometries            (),
    _sfMaterialX              (NULL),
    _sfMaterialY              (NULL),
    _sfMaterialZ              (NULL),
    _sfMaterialSelected       (NULL),
    _sfMaterialRollover       (NULL)
{
}

ManipulatorBase::ManipulatorBase(const ManipulatorBase &source) :
    Inherited(source),
    _sfTarget                 (NULL),
    _sfActiveHandle           (source._sfActiveHandle           ),
    _sfRolloverHandle         (source._sfRolloverHandle         ),
    _sfStartMousePos          (source._sfStartMousePos          ),
    _sfViewport               (NULL),
    _sfMaintainScreenSize     (source._sfMaintainScreenSize     ),
    _sfManipulatorScreenDepth (source._sfManipulatorScreenDepth ),
    _sfLength                 (source._sfLength                 ),
    _sfWidth                  (source._sfWidth                  ),
    _mfXGeometries            (),
    _mfYGeometries            (),
    _mfZGeometries            (),
    _sfMaterialX              (NULL),
    _sfMaterialY              (NULL),
    _sfMaterialZ              (NULL),
    _sfMaterialSelected       (NULL),
    _sfMaterialRollover       (NULL)
{
}


/*-------------------------- destructors ----------------------------------*/

ManipulatorBase::~ManipulatorBase(void)
{
}

void ManipulatorBase::onCreate(const Manipulator *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        Manipulator *pThis = static_cast<Manipulator *>(this);

        pThis->setTarget(source->getTarget());

        pThis->setViewport(source->getViewport());

        MFUnrecGeometryPtr::const_iterator XGeometriesIt  =
            source->_mfXGeometries.begin();
        MFUnrecGeometryPtr::const_iterator XGeometriesEnd =
            source->_mfXGeometries.end  ();

        while(XGeometriesIt != XGeometriesEnd)
        {
            pThis->pushToXGeometries(*XGeometriesIt);

            ++XGeometriesIt;
        }

        MFUnrecGeometryPtr::const_iterator YGeometriesIt  =
            source->_mfYGeometries.begin();
        MFUnrecGeometryPtr::const_iterator YGeometriesEnd =
            source->_mfYGeometries.end  ();

        while(YGeometriesIt != YGeometriesEnd)
        {
            pThis->pushToYGeometries(*YGeometriesIt);

            ++YGeometriesIt;
        }

        MFUnrecGeometryPtr::const_iterator ZGeometriesIt  =
            source->_mfZGeometries.begin();
        MFUnrecGeometryPtr::const_iterator ZGeometriesEnd =
            source->_mfZGeometries.end  ();

        while(ZGeometriesIt != ZGeometriesEnd)
        {
            pThis->pushToZGeometries(*ZGeometriesIt);

            ++ZGeometriesIt;
        }

        pThis->setMaterialX(source->getMaterialX());

        pThis->setMaterialY(source->getMaterialY());

        pThis->setMaterialZ(source->getMaterialZ());

        pThis->setMaterialSelected(source->getMaterialSelected());

        pThis->setMaterialRollover(source->getMaterialRollover());
    }
}

GetFieldHandlePtr ManipulatorBase::getHandleTarget          (void) const
{
    SFUnrecNodePtr::GetHandlePtr returnValue(
        new  SFUnrecNodePtr::GetHandle(
             &_sfTarget,
             this->getType().getFieldDesc(TargetFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleTarget         (void)
{
    SFUnrecNodePtr::EditHandlePtr returnValue(
        new  SFUnrecNodePtr::EditHandle(
             &_sfTarget,
             this->getType().getFieldDesc(TargetFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Manipulator::setTarget,
                    static_cast<Manipulator *>(this), _1));

    editSField(TargetFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleActiveHandle    (void) const
{
    SFUInt16::GetHandlePtr returnValue(
        new  SFUInt16::GetHandle(
             &_sfActiveHandle,
             this->getType().getFieldDesc(ActiveHandleFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleActiveHandle   (void)
{
    SFUInt16::EditHandlePtr returnValue(
        new  SFUInt16::EditHandle(
             &_sfActiveHandle,
             this->getType().getFieldDesc(ActiveHandleFieldId),
             this));


    editSField(ActiveHandleFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleRolloverHandle  (void) const
{
    SFUInt16::GetHandlePtr returnValue(
        new  SFUInt16::GetHandle(
             &_sfRolloverHandle,
             this->getType().getFieldDesc(RolloverHandleFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleRolloverHandle (void)
{
    SFUInt16::EditHandlePtr returnValue(
        new  SFUInt16::EditHandle(
             &_sfRolloverHandle,
             this->getType().getFieldDesc(RolloverHandleFieldId),
             this));


    editSField(RolloverHandleFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleStartMousePos   (void) const
{
    SFPnt2f::GetHandlePtr returnValue(
        new  SFPnt2f::GetHandle(
             &_sfStartMousePos,
             this->getType().getFieldDesc(StartMousePosFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleStartMousePos  (void)
{
    SFPnt2f::EditHandlePtr returnValue(
        new  SFPnt2f::EditHandle(
             &_sfStartMousePos,
             this->getType().getFieldDesc(StartMousePosFieldId),
             this));


    editSField(StartMousePosFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleViewport        (void) const
{
    SFUnrecViewportPtr::GetHandlePtr returnValue(
        new  SFUnrecViewportPtr::GetHandle(
             &_sfViewport,
             this->getType().getFieldDesc(ViewportFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleViewport       (void)
{
    SFUnrecViewportPtr::EditHandlePtr returnValue(
        new  SFUnrecViewportPtr::EditHandle(
             &_sfViewport,
             this->getType().getFieldDesc(ViewportFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Manipulator::setViewport,
                    static_cast<Manipulator *>(this), _1));

    editSField(ViewportFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleMaintainScreenSize (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfMaintainScreenSize,
             this->getType().getFieldDesc(MaintainScreenSizeFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleMaintainScreenSize(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfMaintainScreenSize,
             this->getType().getFieldDesc(MaintainScreenSizeFieldId),
             this));


    editSField(MaintainScreenSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleManipulatorScreenDepth (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfManipulatorScreenDepth,
             this->getType().getFieldDesc(ManipulatorScreenDepthFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleManipulatorScreenDepth(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfManipulatorScreenDepth,
             this->getType().getFieldDesc(ManipulatorScreenDepthFieldId),
             this));


    editSField(ManipulatorScreenDepthFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleLength          (void) const
{
    SFVec3f::GetHandlePtr returnValue(
        new  SFVec3f::GetHandle(
             &_sfLength,
             this->getType().getFieldDesc(LengthFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleLength         (void)
{
    SFVec3f::EditHandlePtr returnValue(
        new  SFVec3f::EditHandle(
             &_sfLength,
             this->getType().getFieldDesc(LengthFieldId),
             this));


    editSField(LengthFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleWidth           (void) const
{
    SFVec3f::GetHandlePtr returnValue(
        new  SFVec3f::GetHandle(
             &_sfWidth,
             this->getType().getFieldDesc(WidthFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleWidth          (void)
{
    SFVec3f::EditHandlePtr returnValue(
        new  SFVec3f::EditHandle(
             &_sfWidth,
             this->getType().getFieldDesc(WidthFieldId),
             this));


    editSField(WidthFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleXGeometries     (void) const
{
    MFUnrecGeometryPtr::GetHandlePtr returnValue(
        new  MFUnrecGeometryPtr::GetHandle(
             &_mfXGeometries,
             this->getType().getFieldDesc(XGeometriesFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleXGeometries    (void)
{
    MFUnrecGeometryPtr::EditHandlePtr returnValue(
        new  MFUnrecGeometryPtr::EditHandle(
             &_mfXGeometries,
             this->getType().getFieldDesc(XGeometriesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&Manipulator::pushToXGeometries,
                    static_cast<Manipulator *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&Manipulator::removeFromXGeometries,
                    static_cast<Manipulator *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&Manipulator::removeObjFromXGeometries,
                    static_cast<Manipulator *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&Manipulator::clearXGeometries,
                    static_cast<Manipulator *>(this)));

    editMField(XGeometriesFieldMask, _mfXGeometries);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleYGeometries     (void) const
{
    MFUnrecGeometryPtr::GetHandlePtr returnValue(
        new  MFUnrecGeometryPtr::GetHandle(
             &_mfYGeometries,
             this->getType().getFieldDesc(YGeometriesFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleYGeometries    (void)
{
    MFUnrecGeometryPtr::EditHandlePtr returnValue(
        new  MFUnrecGeometryPtr::EditHandle(
             &_mfYGeometries,
             this->getType().getFieldDesc(YGeometriesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&Manipulator::pushToYGeometries,
                    static_cast<Manipulator *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&Manipulator::removeFromYGeometries,
                    static_cast<Manipulator *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&Manipulator::removeObjFromYGeometries,
                    static_cast<Manipulator *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&Manipulator::clearYGeometries,
                    static_cast<Manipulator *>(this)));

    editMField(YGeometriesFieldMask, _mfYGeometries);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleZGeometries     (void) const
{
    MFUnrecGeometryPtr::GetHandlePtr returnValue(
        new  MFUnrecGeometryPtr::GetHandle(
             &_mfZGeometries,
             this->getType().getFieldDesc(ZGeometriesFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleZGeometries    (void)
{
    MFUnrecGeometryPtr::EditHandlePtr returnValue(
        new  MFUnrecGeometryPtr::EditHandle(
             &_mfZGeometries,
             this->getType().getFieldDesc(ZGeometriesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&Manipulator::pushToZGeometries,
                    static_cast<Manipulator *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&Manipulator::removeFromZGeometries,
                    static_cast<Manipulator *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&Manipulator::removeObjFromZGeometries,
                    static_cast<Manipulator *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&Manipulator::clearZGeometries,
                    static_cast<Manipulator *>(this)));

    editMField(ZGeometriesFieldMask, _mfZGeometries);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleMaterialX       (void) const
{
    SFUnrecMaterialPtr::GetHandlePtr returnValue(
        new  SFUnrecMaterialPtr::GetHandle(
             &_sfMaterialX,
             this->getType().getFieldDesc(MaterialXFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleMaterialX      (void)
{
    SFUnrecMaterialPtr::EditHandlePtr returnValue(
        new  SFUnrecMaterialPtr::EditHandle(
             &_sfMaterialX,
             this->getType().getFieldDesc(MaterialXFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Manipulator::setMaterialX,
                    static_cast<Manipulator *>(this), _1));

    editSField(MaterialXFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleMaterialY       (void) const
{
    SFUnrecMaterialPtr::GetHandlePtr returnValue(
        new  SFUnrecMaterialPtr::GetHandle(
             &_sfMaterialY,
             this->getType().getFieldDesc(MaterialYFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleMaterialY      (void)
{
    SFUnrecMaterialPtr::EditHandlePtr returnValue(
        new  SFUnrecMaterialPtr::EditHandle(
             &_sfMaterialY,
             this->getType().getFieldDesc(MaterialYFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Manipulator::setMaterialY,
                    static_cast<Manipulator *>(this), _1));

    editSField(MaterialYFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleMaterialZ       (void) const
{
    SFUnrecMaterialPtr::GetHandlePtr returnValue(
        new  SFUnrecMaterialPtr::GetHandle(
             &_sfMaterialZ,
             this->getType().getFieldDesc(MaterialZFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleMaterialZ      (void)
{
    SFUnrecMaterialPtr::EditHandlePtr returnValue(
        new  SFUnrecMaterialPtr::EditHandle(
             &_sfMaterialZ,
             this->getType().getFieldDesc(MaterialZFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Manipulator::setMaterialZ,
                    static_cast<Manipulator *>(this), _1));

    editSField(MaterialZFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleMaterialSelected (void) const
{
    SFUnrecMaterialPtr::GetHandlePtr returnValue(
        new  SFUnrecMaterialPtr::GetHandle(
             &_sfMaterialSelected,
             this->getType().getFieldDesc(MaterialSelectedFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleMaterialSelected(void)
{
    SFUnrecMaterialPtr::EditHandlePtr returnValue(
        new  SFUnrecMaterialPtr::EditHandle(
             &_sfMaterialSelected,
             this->getType().getFieldDesc(MaterialSelectedFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Manipulator::setMaterialSelected,
                    static_cast<Manipulator *>(this), _1));

    editSField(MaterialSelectedFieldMask);

    return returnValue;
}

GetFieldHandlePtr ManipulatorBase::getHandleMaterialRollover (void) const
{
    SFUnrecMaterialPtr::GetHandlePtr returnValue(
        new  SFUnrecMaterialPtr::GetHandle(
             &_sfMaterialRollover,
             this->getType().getFieldDesc(MaterialRolloverFieldId),
             const_cast<ManipulatorBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ManipulatorBase::editHandleMaterialRollover(void)
{
    SFUnrecMaterialPtr::EditHandlePtr returnValue(
        new  SFUnrecMaterialPtr::EditHandle(
             &_sfMaterialRollover,
             this->getType().getFieldDesc(MaterialRolloverFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Manipulator::setMaterialRollover,
                    static_cast<Manipulator *>(this), _1));

    editSField(MaterialRolloverFieldMask);

    return returnValue;
}



#ifdef OSG_MT_CPTR_ASPECT
void ManipulatorBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    Manipulator *pThis = static_cast<Manipulator *>(this);

    pThis->execSync(static_cast<Manipulator *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif



void ManipulatorBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<Manipulator *>(this)->setTarget(NULL);

    static_cast<Manipulator *>(this)->setViewport(NULL);

    static_cast<Manipulator *>(this)->clearXGeometries();

    static_cast<Manipulator *>(this)->clearYGeometries();

    static_cast<Manipulator *>(this)->clearZGeometries();

    static_cast<Manipulator *>(this)->setMaterialX(NULL);

    static_cast<Manipulator *>(this)->setMaterialY(NULL);

    static_cast<Manipulator *>(this)->setMaterialZ(NULL);

    static_cast<Manipulator *>(this)->setMaterialSelected(NULL);

    static_cast<Manipulator *>(this)->setMaterialRollover(NULL);


}


OSG_END_NAMESPACE