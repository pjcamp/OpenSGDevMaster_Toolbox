/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Surface!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

OSG_BEGIN_NAMESPACE


//! access the type of the class
inline
OSG::FieldContainerType &SurfaceBase::getClassType(void)
{
    return _type;
}

//! access the numerical type of the class
inline
OSG::UInt32 SurfaceBase::getClassTypeId(void)
{
    return _type.getId();
}

inline
OSG::UInt16 SurfaceBase::getClassGroupId(void)
{
    return _type.getGroupId();
}

/*------------------------------ get -----------------------------------*/

//! Get the value of the Surface::_sfDimU field.

inline
UInt32 &SurfaceBase::editDimU(void)
{
    editSField(DimUFieldMask);

    return _sfDimU.getValue();
}

//! Get the value of the Surface::_sfDimU field.
inline
      UInt32  SurfaceBase::getDimU(void) const
{
    return _sfDimU.getValue();
}

//! Set the value of the Surface::_sfDimU field.
inline
void SurfaceBase::setDimU(const UInt32 value)
{
    editSField(DimUFieldMask);

    _sfDimU.setValue(value);
}
//! Get the value of the Surface::_sfDimV field.

inline
UInt32 &SurfaceBase::editDimV(void)
{
    editSField(DimVFieldMask);

    return _sfDimV.getValue();
}

//! Get the value of the Surface::_sfDimV field.
inline
      UInt32  SurfaceBase::getDimV(void) const
{
    return _sfDimV.getValue();
}

//! Set the value of the Surface::_sfDimV field.
inline
void SurfaceBase::setDimV(const UInt32 value)
{
    editSField(DimVFieldMask);

    _sfDimV.setValue(value);
}

//! Get the value of the Surface::_sfControlPoints field.
inline
GeoVectorProperty * SurfaceBase::getControlPoints(void) const
{
    return _sfControlPoints.getValue();
}

//! Set the value of the Surface::_sfControlPoints field.
inline
void SurfaceBase::setControlPoints(GeoVectorProperty * const value)
{
    editSField(ControlPointsFieldMask);

    _sfControlPoints.setValue(value);
}
//! Get the value of the Surface::_sfError field.

inline
Real32 &SurfaceBase::editError(void)
{
    editSField(ErrorFieldMask);

    return _sfError.getValue();
}

//! Get the value of the Surface::_sfError field.
inline
      Real32  SurfaceBase::getError(void) const
{
    return _sfError.getValue();
}

//! Set the value of the Surface::_sfError field.
inline
void SurfaceBase::setError(const Real32 value)
{
    editSField(ErrorFieldMask);

    _sfError.setValue(value);
}
//! Get the value of the Surface::_sfNumCurves field.

inline
UInt32 &SurfaceBase::editNumCurves(void)
{
    editSField(NumCurvesFieldMask);

    return _sfNumCurves.getValue();
}

//! Get the value of the Surface::_sfNumCurves field.
inline
      UInt32  SurfaceBase::getNumCurves(void) const
{
    return _sfNumCurves.getValue();
}

//! Set the value of the Surface::_sfNumCurves field.
inline
void SurfaceBase::setNumCurves(const UInt32 value)
{
    editSField(NumCurvesFieldMask);

    _sfNumCurves.setValue(value);
}
//! Get the value of the Surface::_sfIsDelaunay field.

inline
bool &SurfaceBase::editIsDelaunay(void)
{
    editSField(IsDelaunayFieldMask);

    return _sfIsDelaunay.getValue();
}

//! Get the value of the Surface::_sfIsDelaunay field.
inline
      bool  SurfaceBase::getIsDelaunay(void) const
{
    return _sfIsDelaunay.getValue();
}

//! Set the value of the Surface::_sfIsDelaunay field.
inline
void SurfaceBase::setIsDelaunay(const bool value)
{
    editSField(IsDelaunayFieldMask);

    _sfIsDelaunay.setValue(value);
}

//! Get the value of the Surface::_sfTextureControlPoints field.
inline
GeoVectorProperty * SurfaceBase::getTextureControlPoints(void) const
{
    return _sfTextureControlPoints.getValue();
}

//! Set the value of the Surface::_sfTextureControlPoints field.
inline
void SurfaceBase::setTextureControlPoints(GeoVectorProperty * const value)
{
    editSField(TextureControlPointsFieldMask);

    _sfTextureControlPoints.setValue(value);
}
//! Get the value of the Surface::_sfDirtyMask field.

inline
UInt32 &SurfaceBase::editDirtyMask(void)
{
    editSField(DirtyMaskFieldMask);

    return _sfDirtyMask.getValue();
}

//! Get the value of the Surface::_sfDirtyMask field.
inline
      UInt32  SurfaceBase::getDirtyMask(void) const
{
    return _sfDirtyMask.getValue();
}

//! Set the value of the Surface::_sfDirtyMask field.
inline
void SurfaceBase::setDirtyMask(const UInt32 value)
{
    editSField(DirtyMaskFieldMask);

    _sfDirtyMask.setValue(value);
}
//! Get the value of the Surface::_sfSurfaceGLId field.

inline
Int32 &SurfaceBase::editSurfaceGLId(void)
{
    editSField(SurfaceGLIdFieldMask);

    return _sfSurfaceGLId.getValue();
}

//! Get the value of the Surface::_sfSurfaceGLId field.
inline
      Int32  SurfaceBase::getSurfaceGLId(void) const
{
    return _sfSurfaceGLId.getValue();
}

//! Set the value of the Surface::_sfSurfaceGLId field.
inline
void SurfaceBase::setSurfaceGLId(const Int32 value)
{
    editSField(SurfaceGLIdFieldMask);

    _sfSurfaceGLId.setValue(value);
}

//! Get the value of the \a index element the Surface::_mfKnotsU field.
inline
      Real32  SurfaceBase::getKnotsU(const UInt32 index) const
{
    return _mfKnotsU[index];
}

inline
Real32 &SurfaceBase::editKnotsU(const UInt32 index)
{
    editMField(KnotsUFieldMask, _mfKnotsU);

    return _mfKnotsU[index];
}


//! Get the value of the \a index element the Surface::_mfKnotsV field.
inline
      Real32  SurfaceBase::getKnotsV(const UInt32 index) const
{
    return _mfKnotsV[index];
}

inline
Real32 &SurfaceBase::editKnotsV(const UInt32 index)
{
    editMField(KnotsVFieldMask, _mfKnotsV);

    return _mfKnotsV[index];
}


//! Get the value of the \a index element the Surface::_mfKnotLengths field.
inline
      UInt32  SurfaceBase::getKnotLengths(const UInt32 index) const
{
    return _mfKnotLengths[index];
}

inline
UInt32 &SurfaceBase::editKnotLengths(const UInt32 index)
{
    editMField(KnotLengthsFieldMask, _mfKnotLengths);

    return _mfKnotLengths[index];
}


//! Get the value of the \a index element the Surface::_mfDimensions field.
inline
      UInt32  SurfaceBase::getDimensions(const UInt32 index) const
{
    return _mfDimensions[index];
}

inline
UInt32 &SurfaceBase::editDimensions(const UInt32 index)
{
    editMField(DimensionsFieldMask, _mfDimensions);

    return _mfDimensions[index];
}


//! Get the value of the \a index element the Surface::_mfCurveControlPoints field.
inline
const Pnt3f &SurfaceBase::getCurveControlPoints(const UInt32 index) const
{
    return _mfCurveControlPoints[index];
}

inline
Pnt3f &SurfaceBase::editCurveControlPoints(const UInt32 index)
{
    editMField(CurveControlPointsFieldMask, _mfCurveControlPoints);

    return _mfCurveControlPoints[index];
}


//! Get the value of the \a index element the Surface::_mfKnots field.
inline
      Real32  SurfaceBase::getKnots(const UInt32 index) const
{
    return _mfKnots[index];
}

inline
Real32 &SurfaceBase::editKnots(const UInt32 index)
{
    editMField(KnotsFieldMask, _mfKnots);

    return _mfKnots[index];
}


//! Get the value of the \a index element the Surface::_mfCurvesPerLoop field.
inline
      UInt32  SurfaceBase::getCurvesPerLoop(const UInt32 index) const
{
    return _mfCurvesPerLoop[index];
}

inline
UInt32 &SurfaceBase::editCurvesPerLoop(const UInt32 index)
{
    editMField(CurvesPerLoopFieldMask, _mfCurvesPerLoop);

    return _mfCurvesPerLoop[index];
}



#ifdef OSG_MT_CPTR_ASPECT
inline
void SurfaceBase::execSync (      SurfaceBase *pFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    Inherited::execSync(pFrom, whichField, oOffsets, syncMode, uiSyncInfo);

    if(FieldBits::NoField != (DimUFieldMask & whichField))
        _sfDimU.syncWith(pFrom->_sfDimU);

    if(FieldBits::NoField != (DimVFieldMask & whichField))
        _sfDimV.syncWith(pFrom->_sfDimV);

    if(FieldBits::NoField != (KnotsUFieldMask & whichField))
        _mfKnotsU.syncWith(pFrom->_mfKnotsU,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (KnotsVFieldMask & whichField))
        _mfKnotsV.syncWith(pFrom->_mfKnotsV,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (ControlPointsFieldMask & whichField))
        _sfControlPoints.syncWith(pFrom->_sfControlPoints);

    if(FieldBits::NoField != (ErrorFieldMask & whichField))
        _sfError.syncWith(pFrom->_sfError);

    if(FieldBits::NoField != (NumCurvesFieldMask & whichField))
        _sfNumCurves.syncWith(pFrom->_sfNumCurves);

    if(FieldBits::NoField != (KnotLengthsFieldMask & whichField))
        _mfKnotLengths.syncWith(pFrom->_mfKnotLengths,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (DimensionsFieldMask & whichField))
        _mfDimensions.syncWith(pFrom->_mfDimensions,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (CurveControlPointsFieldMask & whichField))
        _mfCurveControlPoints.syncWith(pFrom->_mfCurveControlPoints,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (KnotsFieldMask & whichField))
        _mfKnots.syncWith(pFrom->_mfKnots,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (CurvesPerLoopFieldMask & whichField))
        _mfCurvesPerLoop.syncWith(pFrom->_mfCurvesPerLoop,
                                syncMode,
                                uiSyncInfo,
                                oOffsets);

    if(FieldBits::NoField != (IsDelaunayFieldMask & whichField))
        _sfIsDelaunay.syncWith(pFrom->_sfIsDelaunay);

    if(FieldBits::NoField != (TextureControlPointsFieldMask & whichField))
        _sfTextureControlPoints.syncWith(pFrom->_sfTextureControlPoints);

    if(FieldBits::NoField != (DirtyMaskFieldMask & whichField))
        _sfDirtyMask.syncWith(pFrom->_sfDirtyMask);

    if(FieldBits::NoField != (SurfaceGLIdFieldMask & whichField))
        _sfSurfaceGLId.syncWith(pFrom->_sfSurfaceGLId);
}
#endif


inline
const Char8 *SurfaceBase::getClassname(void)
{
    return "Surface";
}
OSG_GEN_CONTAINERPTR(Surface);

OSG_END_NAMESPACE

